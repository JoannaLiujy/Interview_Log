## 一、数据类型
### 1.一共7种（js红宝书）：
  >简单：Number、String、Boolean、undefined、Null、Symbol
  复杂：Object
  
  ####  Number:常规数字、NaN（和任何值包括自己都不相等）
  > Number()转换字符串：只有数字的转为数字，带其他字符的转为NaN，空字符串转为0
  - 布尔转数字：true：1、false:0
  - null:0
  - undefined:NaN
  - 对象：普通对象转为NaN，数组对象：空数组转为0（先基于toString转为字符串然后再转为数字）
  > parseInt/parseFloat([val],[进制])；对于字符串，从左到右依次查找有效数字字符，直到遇到非有效数字字符，停止查找，并把找到的当数字返回。

  #### String
  > 转换为字符串使用.toString（）；
  - null和undefined禁止直接toString，如果转换，则结果为'null'/'undefined'
  - 对象转换，结果是[object,object] => Object.prototype.toString方法不是转换为字符串的，是用来监测数据类型的
  > 字符串拼接：除加法外，其余都是数学计算，只有加法可能存在字符串拼接（一旦遇到字符串，则不是数学运算，而是字符串拼接）
  - 遇到字符串前都可以做数学运算，一碰到字符串就开始变为拼接
  
  #### boolean
  > 只有0、NaN、''、null、undefined五个转换为false，其余都是true（没有任何特殊情况）
  - ！：取反（先转为布尔，然后取反）
  - ！！ ：转换为布尔值

  #### null/undefined
  > 一般最好用null作为初始的空值，因为0不是空值，在栈内存中有自己的存储空间
  > undefined是没有声明，null是声明了但是没有值

  #### object
  > 普通对象：{[key]:[vlaue]}任何一个对象都是由零到多组键值对组成的，键不能重复
  - 获取属性名对应的属性值：对象.属性名；对象[属性名]（属性名用字符串或数字格式：若属性名是数字，则不能用点的方式获取属性值）
  - 真删除：delete；假删除：设置为空

  > 数组：是特殊的对象数据类型

  ##### 谷歌67增加：BigInt 是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是Javascript中可以用Number表示的最大数字。BigInt可以表示任意大的整数。不能用于 Math 对象中的方法；不能和任何 Number 实例混合运算，两者必须转换成同一种类型。在两种类型来回转换时要小心，因为 BigInt 变量在转换成 Number 变量时可能会丢失精度

### 2.Js中的数据类型检测
  > - typeof：用来监测数据类型的运算符；
  > - instanceof：用来检测当前实例是否属于某个类
  > - constructor：基于构造函数检测数据类型（也是基于类的方式）
  > - Object.prototype.toString.call()：监测数据类型最好的方法

  - typeof [val]:返回的是字符串；可以检测下面的类型：number,string,function,object,boolean,undefined,symbol；
    - typeof null => 'object' 
    - 无法细分出当前值是普通对象还是数组对象，只要是对象就会返回object
  - instanceof


### 3.函数
  > 函数就是一个方法或者一个功能体，就是把实现某个功能的代码放到一起进行封装，以后想要操作实现这个功能，只需要把函数执行即可=》“封装”；减少页面中的冗余代码，提高代码重复使用率（低耦合高内聚）

### 4.浏览器内核
  - webkit(chrome,safari,大部分浏览器)
  - gecko(火狐)
  - presto（Opera）
  - trident（IE）
## 二、堆栈内存以及闭包作用域

### 1.JavaScript的堆栈底层机制
  - 基本类型：按值操作（直接操作的是值），所以也叫作值类型
  - 引用类型：操作的是堆内存的地址（按引用地址操作的）

   > **遇到引用类型值（对象和函数）**
    1.开辟一个新的内存（堆内存16道制的内存地址）
    2.把内容存储在堆内存中（对象存储的是键值对，函数存储的是函数体中的代码字符串）
    3.让变量和地址关联在一起

### 2.变量提升机制
  > 当浏览器开辟出供代码执行的栈内存后，代码并没有自上而下立即执行，而是继续做了一些事情：**把当前作用域中所有带var/function关键字的进行提前的声明和定义=>变量提升机制**
  - 带var的只是提前声明‘var a’，如果只声明没有赋值，默认值是undefined
  - 带function的不仅声明，而且还定义了‘a=13’定义其实就是赋值，准确来说就是让变量和某个值进行关联
  - 带var和不带var的区别：
  ```
  /*
   * 不带var的：相当于给全局对象window设置了一个属性
   */
   a = 13;
   console.log(a);// =>window.a

  /*
   *
   * 带var的：是在全局作用域下声明了一个变量（全局变量），但是在全局下声明的变量也相当于给window增加了一个对应的属性（只有全局作用域具备这个特点）
   */
   var b = 14; // =>创建变量b并给window设置了属性b
   console.log(b); //=>14
   console.log(window.b); //=>14
  ```
  > 在全局作用域：不管条件成不成立，var都要进行变量提升。**但是函数有特殊性，在老版本浏览器中（不论条件是否成立，函数也是提前声明或定义），在新版本浏览器中（为了兼容es6的严谨语法规范，条件中的函数在变量提升阶段只能提前声明，不能提前定义），如果条件成立，块级作用域中给fn赋值再执行**

### 3.let/const/var区别
  `1.let和const不存在变量提升机制`
  > 创建变量的六种方式中：var/function有变量提升，而let/const/class/import都不存在这个机制

  `2.var允许重复声明，而let是不允许的`
  > 在相同的作用域中（或执行上下文中），所谓的重复是：不管之前通过什么办法，只要当前栈内存中存在了这个变量，我们是用let/const等重复再声明这个变量就是语法错误
  - 如果使用var/function关键词声明变量并且重复声明，是不会有影响的（声明第一次之后，之后再遇到就不再重复声明了）
  - 但是使用let/const就不行，浏览器会校验当前作用域中是否已经存在这个变量了，如果已经存在了，则再次基于let等重新声明就会报错 
  
  ```
    // 在浏览器开辟栈内存供代码自上而下执行之前，不仅有变量提升操作，还有很多其他的操作=》‘词法解析’或‘词法检测’：就是检测当前即将要执行的代码是否会出现语法错误（SyntaxError），如果出现错误，代码将不会再执行（第一行都不会执行）
    console.log(1); // 这行就不会再执行了
    let a = 12;
    console.log(a);
    let a = 13;
    console.log(a);
    // =>直接报错，什么也不输出
  ```
  `3.let能解决typeof检测时出现的暂时性死区问题（let比var更严谨）`

  ```
    // console.log(a); //=>a is not defined

    // console.log(typeof a); //=>本应报错，因为没有a，但是会输出undefined，称为暂时性死区

    console.log(typeof a);
    let a;
    //=>报错
  ```
### 4.自执行函数：前面加的（）或！、-、~、+只是让语法符合
  - (function(n){})(10);
  - ~function(n){}(10);
  - !function(n){}(10);
  - +function(n){}(10);
  - -function(n){}(10);

### 5.作用域链查找机制（私有栈内存中的变量处理）
  > 知识点：私有栈内存中代码执行的时候，如果遇到一个变量：1.首先看是否为自己家的，是自己的以后操作都用自己的，不是自己的去上级作用域中查找，一直找到全局作用域为止。2.找到就用，找不到就可能报错。
  
  ``` 
    var a = 10,b = 20; // 等价于var a=10;var b=20;
    var a = b = 10; // 等价于var a=10;b=10(b不带var)
  ```

  - 函数执行形成的私有栈内存，会把内存中所有的私有变量保护起来，和外面的没有关系，函数的这种保护机制就是**闭包**
  - 私有变量：在私有作用域中变量存储区存储的变量（1.函数中带var/let/function/const...的变量。2.形参变量）

  > 作用域链查找机制，关键在于如何查找上级作用域：1.从函数创建开始，作用于就已经指定好了。2.当前函数是在哪个作用域N下创建的，那么函数执行形成的作用域M的上级作用域就是N，和函数在哪执行的没关系，只和创建的地方有关系。

### 6.闭包机制
#### 闭包作用域

  `1.创建函数`
  
  - 开辟一个堆内存
  - 把函数体中的代码当做字符串存储进去
  - 把对内存的地址赋值给函数名/变量名
  - **函数在哪创建，那么它执行时候所需要的查找的上级作用域就是谁**
    
  `2.函数执行`

  - 形成一个全新的私有作用域、执行上下文、私有栈内存（执行一次形成一个，多个之间也不会产生影响）
  - 形参赋值&变量提升
  - 代码执行（把所属堆内存中的代码字符串拿出来一行行执行）
  - **遇到一个变量，首先看它是否为私有变量（形参和在私有作用域中声明的变量是私有变量），是私有的就操作自己的变量即可，不是的泽祥上级作用域中查找，一直找到全局作用域为止=>作用域链查找机制**
  - 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制就是**闭包的保护机制**

  `3.关于堆栈内存释放问题`

  > 函数执行就会形成栈内存（从内存中分配的一块空间），如果内存都不销毁释放，就很容易会导致栈内存溢出，堆栈内存的释放是js的核心

  `(1)堆内存释放问题`

  ```
    // 创建一个引用类型值，就会产生一个堆内存
    // 如果当前创建的堆内存不被其他东西所占用了（浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的都会给回收释放掉），则会释放
    let obj = {
      name : 'ailing'
    }
    let oop = obj;
    // 此时的obj和oop都占用这对象的内存，想要释放对内存，需要手动解除变量和值的关联（null：空对象指针）
    obj = null;
    oop = null;
  ```

  `(2)栈内存释放问题`

  ```
    // 打开浏览器形成的全局作用域、手动执行函数形成的私有作用域、基于es6中的let/const形成的块作用域。。。都是栈内存。

    /*
     * 全局栈内存：关掉页面的时候才会销毁
     * 私有栈内存：
     *     1.一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁释放掉(排除死递归、出现死循环的模式)。
     *     2.但是一旦占内存中的某个东西（一般都是堆地址）被私有作用域以外的事物给占用了，则当前私有栈内存不能立即被释放销毁（特点：私有作用域中的私有变量等信息也保留下来了） ==》市面上认为的闭包:函数执行形成的不能被释放的私有栈内存，才是闭包
     */
     function fn(){
       // ...
     }
     fn(); //=>函数执行形成栈内存，执行完成栈内存销毁
  ```
#### 闭包两大作用
  > 1.保护（私有变量和外界没有必然联系）
  > 2.保存（形成不销毁的栈内存，里面的私有变量等信息保存下来了）

  - 从性能角度讲，我们真实项目中应该减少对闭包的使用（因为闭包会产生不释放的栈内存，过多使用容易导致内存溢出或者性能降低）


### 3.函数
#### 任意数求和，函数中的arguments
  > 任意数求和：1.传递的实参个数不定 2.传递的值是否为有效数字不定=》把传递的有效数字进行相加求和
  arguments：函数内置的实参集合
    - 1. 类数组集合，集合中存储着所有函数执行时传递的实参信息
    - 2. 无论是否设置形参，arguments都存在
    - 3. 无论是否传递实参，arguments也都存在
    arguments.callee:存储的是当前函数本身（一般不用的，js严格模式下禁止使用这些属性）

#### 箭头函数
  > 1. 简单：函数体中只有一行return代码时，直接省略return和大括号；形参赋值默认值（当没有给形参传递实参的时候，执行默认值） 
  > 2. 箭头函数没有arguments（类数组），但可以使用剩余运算符获取到实参集合（纯数组）  
  ```
  let sum = (...arg) => {
    console.log(arg);
  }
  sum(10, 20, 30, 40);
  ```
  > 3. this也便于操作

#### 柯里化函数
> 预先处理的思想：利用闭包的机制



### 4.浏览器底层渲染原理

- 遇到link/img/audio/video等是异步去加载资源信息（浏览器分配在一个新的线程去加载，主线程继续向下渲染页面）
- 遇到的是script或者@import，则让主线程去加载资源信息（同步），加载完成信息后，再去继续渲染页面

